/*
 *  Part 5 - Changing Program Execution Flow by Performing a Return To Libc attack
 *           with a Stack Based Buffer Overflow
 *  Task - Modify the program's GOT in order to trick the program into calling a 
 *         series of ROP gadgets which end up spawning a shell
 *  */

#include <stdio.h>
#include <unistd.h>
#include <string.h>

#define DEBUG 1

void printStack(char **stack, void* returnAddr) {
    char **stackAddress;

    printf("Our stack looks like\n");
    for (stackAddress = stack; stackAddress < stack + 0x20; stackAddress++) {
        printf("%p : %p", stackAddress, *stackAddress);
        if ((void *) *stackAddress == returnAddr)
            printf(" <-- Saved EIP (return address)");
        printf("\n");
    }
    printf("\n");
}

void printDebugInfo(void *ret, char **stack) {
    // Print the return address of the function we are in
    printf("Our return address is: %p\n", ret);

    // Print what our stack looks like right now
    printStack(stack, ret);
}

void returnToLibc() {
    char buffer[0];
    char **stack;

    memset(buffer, 0, sizeof(buffer));

    if (DEBUG) {
        puts("Entered function: returnToLibc\n");

        void *ret =  __builtin_return_address(0);
        stack = (char **) (&stack);
        printDebugInfo(ret, stack);
    }

    printf("Can you Return to Libc Bro?: "); fflush(stdout);
    read(0, buffer, 0x100);
    write(1, buffer, 0x100);
    printf("\n");

    if (DEBUG) {
        void *ret =  __builtin_return_address(0);
        stack = (char **) (&stack);
        printDebugInfo(ret, stack);

        puts("Leaving function: returnToLibc");
    }
}

void returnToLibcWithoutDebugInfo() {
    char buffer[0];

    memset(buffer, 0, sizeof(buffer));

    printf("Can you Return to Libc Bro?: "); fflush(stdout);
    read(0, buffer, 0x100);
    write(1, buffer, 0x100);

    printf("\n");
}

int main() {
    returnToLibc();

    puts("I don't think you returned to Libc :C");

    return 0;
}



